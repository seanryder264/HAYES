/*
 * measure.c
 *
 *  Created on: Jun 9, 2025
 *      Author: yuki
 */

#include "measure.h"
#include "main.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

#include "arm_math.h"
#include "math.h"

#include "ssd1306_fonts.h"
#include "ssd1306.h"
#include "ssd1306_conf.h"
#include "stdio.h"

#define TIM_TO_ADC_RAITO    28  // 1.5 + 12.5 ADC time, /2 ADC clock
#define IC_PSC              8   // Prescaler on input capture channels
#define CLK_KHZ             72000

#define F_C_0 610
#define F_C_1 563
#define F_C_2 516
#define F_C_3 487
#define F_C_4 452
#define F_C_5 411
#define F_C_6 367
#define F_C_7 333
#define F_C_8 300

#define F_0_0 650
#define F_0_1 585
#define F_1_2 539
#define F_2_3 501
#define F_3_4 469
#define F_4_5 431
#define F_5_6 389
#define F_6_7 350
#define F_7_8 315
#define F_8_8 280

#define NAF_C (2 * PI * TIM_TO_ADC_RAITO) / (CLK_KHZ)

#define SIZE_X 2
#define SIZE_Y 2

extern TIM_HandleTypeDef htim16;

extern COMP_HandleTypeDef hcomp3;
extern COMP_HandleTypeDef hcomp4;
extern COMP_HandleTypeDef hcomp5;
extern COMP_HandleTypeDef hcomp6;

static TaskHandle_t xTaskToNotify = NULL;

void measure(void *pvParameters)
{
    //measure_task_params *params = (measure_task_params *) pvParameters;

    xTaskToNotify = xTaskGetCurrentTaskHandle();
    volatile measure_cell grid[SIZE_X * SIZE_Y];
    static measure_group measurements;

    uint16_t freq_khz;
    uint32_t diff;
    uint8_t ident;

    float amplitude;
    float norm_ang_freq = NAF_C * 610;
    float I;
    float Q;

    char buffer[50];

    int16_t *ADC;
    uint16_t *IC;

    uint16_t cell_index;

    xTaskNotifyGive(xTaskToNotify);

    while (1) {
        for (uint8_t cell_x = 0; cell_x < SIZE_X; cell_x ++){
            for (uint8_t cell_y = 0; cell_y < SIZE_Y; cell_y ++) {

                measure_collect(&measurements, cell_x, cell_y);

                vTaskDelay(1); // add delay time for timer
                ulTaskNotifyTake(pdFALSE, portMAX_DELAY);

                for (uint8_t channel = 0; channel < 1; channel ++) {

                    I = 0;
                    Q = 0;
                    amplitude = 0;
    
                    ADC = measurements.samples[channel].ADC_buffer;
                    IC  = measurements.samples[channel].IC_buffer; 
    
                    HAL_GPIO_WritePin(TP906_GPIO_Port, TP906_Pin, SET);
    
                    if (IC[1] == IC[0]) {
                        freq_khz = 0;
                    }else if (IC[1] > IC[0]) {
                        diff = (IC[1] - IC[0]);
                        freq_khz = (CLK_KHZ * IC_PSC / diff);
                    } else {
                        diff = (0x10000 + IC[1] - IC[0]);
                        freq_khz = (CLK_KHZ * IC_PSC / diff);
                    }
    
                    norm_ang_freq = freq_khz * NAF_C;
                    for (uint16_t sample = 0; sample < 128; sample ++) {
                        I += arm_cos_f32(norm_ang_freq * sample) * ADC[sample];
                        Q += arm_sin_f32(norm_ang_freq * sample) * ADC[sample];
                    }
                    amplitude = sqrtf(I*I + Q*Q);
    
    
                    if ((freq_khz >= F_8_8) & (freq_khz < F_7_8)) {
                        ident = 8;
                    } else if ((freq_khz >= F_7_8) & (freq_khz < F_6_7)) {
                        ident = 7;
                    } else if ((freq_khz >= F_6_7) & (freq_khz < F_5_6)) {
                        ident = 6;
                    } else if ((freq_khz >= F_5_6) & (freq_khz < F_4_5)) {
                        ident = 5;
                    } else if ((freq_khz >= F_4_5) & (freq_khz < F_3_4)) {
                        ident = 4;
                    } else if ((freq_khz >= F_3_4) & (freq_khz < F_2_3)) {
                        ident = 3;
                    } else if ((freq_khz >= F_2_3) & (freq_khz < F_1_2)) {
                        ident = 2;
                    } else if ((freq_khz >= F_1_2) & (freq_khz < F_0_1)) {
                        ident = 1;
                    } else if ((freq_khz >= F_0_1) & (freq_khz < F_0_0)) {
                        ident = 0;
                    } else {
                        ident = 255;
                    }
    
                    if (amplitude < 150000) {
                        ident = 255;
                    }

                    //check amplitude for clipping/overflow
                    //yamplitude = (uint8_t)((amplitude / 1500000) * 255);
    
                    cell_index = cell_x + cell_y * SIZE_Y + channel * 256;
                    grid[cell_index].amplitude = amplitude;
                    grid[cell_index].frequency = ident;
                }
            }
        }
        __ASM("nop");
            
        ssd1306_Fill(White);
    
        sprintf(buffer, "%g %g", grid[0].amplitude, grid[1].amplitude);
        ssd1306_SetCursor(6, 20);
        ssd1306_WriteString(buffer, Font_6x8, Black);
        sprintf(buffer, "%g %g", grid[2].amplitude, grid[3].amplitude);
        ssd1306_SetCursor(6, 32);
        ssd1306_WriteString(buffer, Font_6x8, Black);

        ssd1306_UpdateScreen();
        HAL_GPIO_WritePin(TP906_GPIO_Port, TP906_Pin, RESET);
    }
    vTaskDelete(NULL);
}

void measure_collect(measure_group *measurements, uint8_t cell_x, uint8_t cell_y)
{
    uint32_t frame = 1U << cell_x;

    //bounds checking
    HAL_GPIO_WritePin(MUX_A_GPIO_Port, MUX_A_Pin, (cell_y >> 0) & 1U);
    HAL_GPIO_WritePin(MUX_B_GPIO_Port, MUX_B_Pin, (cell_y >> 1) & 1U);
    HAL_GPIO_WritePin(MUX_C_GPIO_Port, MUX_C_Pin, (cell_y >> 2) & 1U);

    taskENTER_CRITICAL();
    HAL_SPI_Transmit(&hspi1, (uint8_t *) &frame, 4, 1000);

    HAL_GPIO_WritePin(TX_RCLK_GPIO_Port, TX_RCLK_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(TX_RCLK_GPIO_Port, TX_RCLK_Pin, GPIO_PIN_RESET);

    HAL_GPIO_WritePin(TX_SLEEP_GPIO_Port, TX_SLEEP_Pin, GPIO_PIN_SET);

    for (uint8_t j = 0; j < 60; j ++) {
        __ASM("nop");
    }

    HAL_GPIO_WritePin(TX_SLEEP_GPIO_Port, TX_SLEEP_Pin, GPIO_PIN_RESET);

    for (uint8_t j = 0; j < 60; j ++) {
        __ASM("nop");
    }

    HAL_ADC_Start_DMA(&hadc4, (uint32_t *) measurements->samples[0].ADC_buffer, 256);
    HAL_TIM_IC_Start_DMA(&htim16, TIM_CHANNEL_1, (uint32_t*) measurements->samples[0].IC_buffer, 2);
    HAL_GPIO_TogglePin(TP908_GPIO_Port, TP908_Pin);
    taskEXIT_CRITICAL();
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
    HAL_ADC_Stop_DMA(&hadc4);
    vTaskNotifyGiveFromISR(xTaskToNotify, NULL);
    HAL_GPIO_TogglePin(TP908_GPIO_Port, TP908_Pin);
}

